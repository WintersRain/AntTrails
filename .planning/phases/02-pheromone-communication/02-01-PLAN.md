---
phase: 02-pheromone-communication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/systems/pheromone.rs
autonomous: true

must_haves:
  truths:
    - "Pheromone decay runs per-tick with type-specific rates: food 0.02, home 0.005, danger 0.05"
    - "Adaptive deposit prevents saturation -- a single ant's trail stabilizes at ~0.71 (not 1.0)"
    - "Diffusion spreads pheromone to 8 neighbors at 5% per tick using a permanent double buffer (no per-tick allocation)"
    - "Home pheromone deposit is proximity-scaled -- ants far from nest deposit nothing, ants near nest deposit full amount"
    - "Weighted random gradient selection replaces greedy 'pick strongest neighbor' approach"
  artifacts:
    - path: "src/systems/pheromone.rs"
      provides: "Rewritten pheromone system with adaptive deposit, per-tick type-specific decay, diffusion, and weighted gradient"
      contains: "deposit_adaptive"
    - path: "src/systems/pheromone.rs"
      provides: "Double-buffer diffusion infrastructure"
      contains: "buffer: Vec<f32>"
    - path: "src/systems/pheromone.rs"
      provides: "Weighted gradient following method"
      contains: "get_gradient_weighted"
  key_links:
    - from: "src/systems/pheromone.rs::decay_all"
      to: "DECAY_FOOD, DECAY_HOME, DECAY_DANGER constants"
      via: "Per-type decay rates applied in strides of 3"
      pattern: "DECAY_FOOD|DECAY_HOME|DECAY_DANGER"
    - from: "src/systems/pheromone.rs::deposit_adaptive"
      to: "MAX_PHEROMONE"
      via: "Adaptive formula: base * (1.0 - current/max)"
      pattern: "1\\.0 - current"
    - from: "src/systems/pheromone.rs::diffuse"
      to: "self.buffer"
      via: "Double-buffer swap pattern"
      pattern: "self\\.buffer|std::mem::swap"
---

<objective>
Rewrite the pheromone system core in pheromone.rs: replace broken constants, add adaptive deposit, per-tick type-specific decay, spatial diffusion with double-buffering, proximity-scaled home deposit, and weighted random gradient following.

Purpose: The current pheromone system is broken by 3-4 orders of magnitude -- every cell saturates to MAX_PHEROMONE=1.0, destroying all gradients and making pheromone-following degenerate to random movement. This plan fixes the mathematical foundation so that trails can form meaningful gradients.

Output: A fully rewritten pheromone.rs with correct constants, adaptive deposit method, per-type decay, diffusion system, and improved gradient following. The file compiles but is NOT yet wired into the game loop (that is Plan 02-02).
</objective>

<execution_context>
@C:\Users\winte\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\winte\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-pheromone-communication/02-RESEARCH.md
@src/systems/pheromone.rs
@src/colony.rs
@src/components.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite PheromoneGrid struct, constants, decay, and diffusion</name>
  <files>src/systems/pheromone.rs</files>
  <action>
  **Replace ALL constants at the top of pheromone.rs** (after the imports, before the enum):

  Remove:
  ```rust
  const DECAY_RATE: f32 = 0.001;
  const DEPOSIT_AMOUNT: f32 = 0.05;
  ```

  Add these constants in their place:
  ```rust
  /// Per-type decay rates (per tick, multiplicative)
  const DECAY_FOOD: f32 = 0.02;    // Half-life ~34 ticks (~1.1s @30fps)
  const DECAY_HOME: f32 = 0.005;   // Half-life ~138 ticks (~4.6s @30fps)
  const DECAY_DANGER: f32 = 0.05;  // Half-life ~14 ticks (~0.5s @30fps)

  /// Snap-to-zero threshold (eliminates lingering near-zero values)
  const SNAP_TO_ZERO: f32 = 0.001;

  /// Base deposit amounts (before adaptive scaling)
  const DEPOSIT_FOOD_BASE: f32 = 0.05;
  const DEPOSIT_HOME_BASE: f32 = 0.03;
  const DEPOSIT_DANGER_BASE: f32 = 0.10;

  /// Diffusion rate: fraction of pheromone that spreads to neighbors per tick
  const DIFFUSION_RATE: f32 = 0.05;

  /// Home pheromone deposit radius (Manhattan distance from nest)
  const HOME_DEPOSIT_RADIUS: f32 = 30.0;
  ```

  Keep `MAX_PHEROMONE: f32 = 1.0` unchanged.

  **Add a `buffer` field to PheromoneGrid struct:**

  Change:
  ```rust
  pub struct PheromoneGrid {
      pub width: usize,
      pub height: usize,
      data: Vec<f32>,
      pub max_colonies: usize,
  }
  ```

  To:
  ```rust
  pub struct PheromoneGrid {
      pub width: usize,
      pub height: usize,
      data: Vec<f32>,
      buffer: Vec<f32>,  // Diffusion scratch buffer (permanent, not per-tick allocated)
      pub max_colonies: usize,
  }
  ```

  **Update `PheromoneGrid::new()` to initialize the buffer:**

  Change the `new()` function to:
  ```rust
  pub fn new(width: usize, height: usize, max_colonies: usize) -> Self {
      let size = width * height * max_colonies * 3;
      Self {
          width,
          height,
          data: vec![0.0; size],
          buffer: vec![0.0; size],
          max_colonies,
      }
  }
  ```

  **Rewrite `decay_all()` with per-type decay rates:**

  Replace the existing `decay_all` method with:
  ```rust
  pub fn decay_all(&mut self) {
      // Data layout: strides of 3 per colony = [food, home, danger]
      // Total stride per cell = max_colonies * 3
      // Process in strides of 3 to apply per-type rates
      for chunk in self.data.chunks_exact_mut(3) {
          // Food (index 0)
          chunk[0] *= 1.0 - DECAY_FOOD;
          if chunk[0] < SNAP_TO_ZERO { chunk[0] = 0.0; }
          // Home (index 1)
          chunk[1] *= 1.0 - DECAY_HOME;
          if chunk[1] < SNAP_TO_ZERO { chunk[1] = 0.0; }
          // Danger (index 2)
          chunk[2] *= 1.0 - DECAY_DANGER;
          if chunk[2] < SNAP_TO_ZERO { chunk[2] = 0.0; }
      }
  }
  ```

  **Add `diffuse()` method** to PheromoneGrid (after `decay_all`, inside the `impl` block):

  ```rust
  /// Spread pheromone to 8 neighbors using double-buffer swap
  pub fn diffuse(&mut self) {
      // Zero the buffer
      for v in self.buffer.iter_mut() {
          *v = 0.0;
      }

      let cardinal_weight: f32 = 1.0;
      let diagonal_weight: f32 = 0.707; // ~1/sqrt(2)
      let total_weight: f32 = 4.0 * cardinal_weight + 4.0 * diagonal_weight;

      let directions: [(i32, i32); 8] = [
          (0, -1), (0, 1), (-1, 0), (1, 0),     // Cardinal
          (-1, -1), (1, -1), (-1, 1), (1, 1),    // Diagonal
      ];

      for y in 0..self.height as i32 {
          for x in 0..self.width as i32 {
              for colony in 0..self.max_colonies as u8 {
                  for ptype in [PheromoneType::Food, PheromoneType::Home, PheromoneType::Danger] {
                      if let Some(i) = self.index(x, y, colony, ptype) {
                          let val = self.data[i];
                          if val < SNAP_TO_ZERO { continue; }

                          let spread = val * DIFFUSION_RATE;
                          self.buffer[i] += val - spread; // Cell keeps most of its value

                          // Spread to neighbors
                          for (dx, dy) in &directions {
                              if let Some(ni) = self.index(x + dx, y + dy, colony, ptype) {
                                  let weight = if dx.abs() + dy.abs() == 1 {
                                      cardinal_weight
                                  } else {
                                      diagonal_weight
                                  };
                                  self.buffer[ni] += spread * weight / total_weight;
                              }
                          }
                      }
                  }
              }
          }
      }

      // Swap buffers (O(1) pointer swap, no allocation)
      std::mem::swap(&mut self.data, &mut self.buffer);
  }
  ```

  NOTE: The `index()` method is private. `diffuse()` is inside the `impl PheromoneGrid` block, so it has access to `index()`. Make sure `diffuse()` is placed inside the impl block alongside `new()`, `index()`, `get()`, etc.
  </action>
  <verify>
  Run `cargo build` from the project root. Expect:
  - No errors related to the new `buffer` field (struct and constructor updated together)
  - No errors in `decay_all()` (chunks_exact_mut(3) works on the flat array since data length is always a multiple of 3)
  - No errors in `diffuse()` (uses only existing internal methods)
  - Warnings about `DEPOSIT_FOOD_BASE`, `DEPOSIT_HOME_BASE`, `DEPOSIT_DANGER_BASE`, `HOME_DEPOSIT_RADIUS` being unused are expected (they will be used in Task 2)
  - Warning about `DEPOSIT_AMOUNT` being unused is expected if it still exists -- actually it should be removed. Verify it is gone.
  </verify>
  <done>
  PheromoneGrid has a permanent `buffer` field for diffusion. `decay_all()` applies per-type decay rates (food 0.02, home 0.005, danger 0.05) with snap-to-zero. `diffuse()` spreads pheromone to 8 neighbors at 5% rate using buffer swap. Old `DECAY_RATE` and `DEPOSIT_AMOUNT` constants are removed. `cargo build` succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add adaptive deposit, proximity-based home deposit, and weighted gradient</name>
  <files>src/systems/pheromone.rs</files>
  <action>
  **Add `deposit_adaptive()` method** to PheromoneGrid (alongside existing `deposit()` method):

  ```rust
  /// Adaptive deposit: effective amount decreases as cell concentration rises
  /// Formula: effective = base * (1.0 - current / MAX_PHEROMONE)
  pub fn deposit_adaptive(
      &mut self, x: i32, y: i32, colony: u8,
      ptype: PheromoneType, base_amount: f32,
  ) {
      if let Some(i) = self.index(x, y, colony, ptype) {
          let current = self.data[i];
          let effective = base_amount * (1.0 - current / MAX_PHEROMONE);
          self.data[i] = (current + effective).min(MAX_PHEROMONE);
      }
  }
  ```

  **Add `get_gradient_weighted()` method** to PheromoneGrid (alongside existing `get_gradient()` method). Do NOT remove the old `get_gradient()` yet -- it may be referenced elsewhere and will be retired in Plan 02-02:

  ```rust
  /// Weighted random gradient selection: probability proportional to strength^2
  /// This replaces greedy "pick strongest" which fails under saturation
  pub fn get_gradient_weighted(
      &self, x: i32, y: i32, colony: u8, ptype: PheromoneType,
  ) -> Option<(i32, i32)> {
      let directions = [
          (0, -1), (0, 1), (-1, 0), (1, 0),
          (-1, -1), (1, -1), (-1, 1), (1, 1),
      ];

      // Collect neighbors with non-negligible pheromone
      let mut candidates: Vec<((i32, i32), f32)> = Vec::new();

      for (dx, dy) in directions {
          let strength = self.get(x + dx, y + dy, colony, ptype);
          if strength > 0.01 {
              candidates.push(((dx, dy), strength));
          }
      }

      if candidates.is_empty() {
          return None;
      }

      // Weighted random: probability proportional to strength^2
      // Squaring emphasizes stronger trails while allowing some exploration
      let total: f32 = candidates.iter().map(|(_, s)| s * s).sum();
      let mut roll = fastrand::f32() * total;

      for ((dx, dy), s) in &candidates {
          roll -= s * s;
          if roll <= 0.0 {
              return Some((*dx, *dy));
          }
      }

      // Fallback to last candidate (floating-point edge case)
      candidates.last().map(|((dx, dy), _)| (*dx, *dy))
  }
  ```

  **Rewrite `pheromone_deposit_system()` to use adaptive deposit and proximity-based home pheromone:**

  First, update the function signature to accept colonies:
  ```rust
  pub fn pheromone_deposit_system(
      world: &World, pheromones: &mut PheromoneGrid, colonies: &[ColonyState],
  ) {
  ```

  Add the import for `ColonyState` at the top of the file (alongside existing imports):
  ```rust
  use crate::colony::ColonyState;
  ```

  Replace the entire body of `pheromone_deposit_system` with:
  ```rust
  pub fn pheromone_deposit_system(
      world: &World, pheromones: &mut PheromoneGrid, colonies: &[ColonyState],
  ) {
      for (_entity, (pos, ant, member)) in world.query::<(&Position, &Ant, &ColonyMember)>().iter() {
          let colony_id = member.colony_id;

          match ant.state {
              // Carrying ants lay FOOD pheromone (they found food, others should follow)
              AntState::Carrying => {
                  pheromones.deposit_adaptive(
                      pos.x, pos.y, colony_id,
                      PheromoneType::Food, DEPOSIT_FOOD_BASE,
                  );
              }
              // Wandering/Returning ants lay HOME pheromone near nest only
              AntState::Wandering | AntState::Returning => {
                  if let Some(colony) = colonies.get(colony_id as usize) {
                      let dist = ((pos.x - colony.home_x).abs()
                          + (pos.y - colony.home_y).abs()) as f32;
                      let proximity = (1.0 - dist / HOME_DEPOSIT_RADIUS).max(0.0);
                      if proximity > 0.0 {
                          pheromones.deposit_adaptive(
                              pos.x, pos.y, colony_id,
                              PheromoneType::Home, DEPOSIT_HOME_BASE * proximity,
                          );
                      }
                  }
              }
              // Digging ants leave faint home pheromone near nest
              AntState::Digging => {
                  if let Some(colony) = colonies.get(colony_id as usize) {
                      let dist = ((pos.x - colony.home_x).abs()
                          + (pos.y - colony.home_y).abs()) as f32;
                      let proximity = (1.0 - dist / 20.0).max(0.0);
                      if proximity > 0.0 {
                          pheromones.deposit_adaptive(
                              pos.x, pos.y, colony_id,
                              PheromoneType::Home, DEPOSIT_HOME_BASE * 0.5 * proximity,
                          );
                      }
                  }
              }
              // Other states don't deposit (combat system handles danger pheromone)
              _ => {}
          }
      }
  }
  ```

  **Update `follow_pheromone()` to use `get_gradient_weighted()` instead of `get_gradient()`:**

  Replace the body of `follow_pheromone()`:
  ```rust
  pub fn follow_pheromone(
      pheromones: &PheromoneGrid,
      x: i32, y: i32, colony: u8,
      ptype: PheromoneType,
      terrain: &Terrain,
  ) -> Option<(i32, i32)> {
      if let Some((dx, dy)) = pheromones.get_gradient_weighted(x, y, colony, ptype) {
          if terrain.is_passable(x + dx, y + dy) {
              return Some((dx, dy));
          }
      }
      None
  }
  ```

  IMPORTANT: Keep the old `get_gradient()` method in PheromoneGrid -- do NOT delete it. Other code (combat.rs `fighting_movement`, `fleeing_movement`) may still reference it. Those will be migrated in a future phase. Annotate it with `#[allow(dead_code)]` only if it becomes unused after this plan.
  </action>
  <verify>
  Run `cargo build` from the project root. Expect:
  - Compilation error: `pheromone_deposit_system` now takes 3 arguments but call site in app.rs still passes 2. This is EXPECTED -- app.rs will be updated in Plan 02-02. For now, temporarily check compilation by:
    1. Running `cargo check 2>&1` and confirming the ONLY error is the call site mismatch in app.rs (line ~205)
    2. No other errors related to the new methods or constants
  - The error should say something like "this function takes 3 arguments but 2 arguments were supplied"
  - All new methods (`deposit_adaptive`, `get_gradient_weighted`, `diffuse`) should compile without errors in isolation
  </verify>
  <done>
  `deposit_adaptive()` prevents saturation via formula `base * (1.0 - current/max)`. `get_gradient_weighted()` uses probability-proportional-to-strength^2 selection. `pheromone_deposit_system()` accepts colonies and uses proximity-based home deposit (fades to zero at 30 tiles from nest). `follow_pheromone()` uses the new weighted gradient. `cargo check` produces only the expected app.rs call-site mismatch error.
  </done>
</task>

</tasks>

<verification>
1. `cargo check 2>&1` produces exactly one error: `pheromone_deposit_system` argument count mismatch in app.rs (expected 3, got 2). No other errors.
2. `grep -n "DECAY_RATE\|DEPOSIT_AMOUNT" src/systems/pheromone.rs` returns zero results (old constants removed)
3. `grep -n "DECAY_FOOD\|DECAY_HOME\|DECAY_DANGER" src/systems/pheromone.rs` returns 3+ results (new constants exist)
4. `grep -n "deposit_adaptive" src/systems/pheromone.rs` returns 4+ results (method + calls)
5. `grep -n "get_gradient_weighted" src/systems/pheromone.rs` returns 2+ results (method + call in follow_pheromone)
6. `grep -n "buffer" src/systems/pheromone.rs` returns 3+ results (field, init, swap)
7. `grep -n "HOME_DEPOSIT_RADIUS\|proximity" src/systems/pheromone.rs` returns results (proximity-based home deposit)
</verification>

<success_criteria>
- Old DECAY_RATE (0.001) and DEPOSIT_AMOUNT (0.05) constants are gone
- Per-type decay rates applied: food 0.02, home 0.005, danger 0.05
- Adaptive deposit formula: effective = base * (1.0 - current/MAX_PHEROMONE)
- Double-buffer diffusion at 5% rate with permanent buffer field (no per-tick alloc)
- Weighted random gradient following replaces greedy pick-strongest
- Home pheromone deposit scales to zero beyond 30 tiles from nest
- The only compilation error is the app.rs call-site mismatch (fixed in Plan 02-02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pheromone-communication/02-01-SUMMARY.md`
</output>
