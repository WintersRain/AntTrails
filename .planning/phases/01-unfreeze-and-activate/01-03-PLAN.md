---
phase: 01-unfreeze-and-activate
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/spatial.rs
  - src/systems/mod.rs
  - src/app.rs
  - src/systems/combat.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "The simulation runs at 30 FPS with 500+ ants on screen without frame drops from neighbor lookups"
    - "Combat between ants from different colonies still occurs correctly -- enemies adjacent to each other fight"
    - "Proximity queries are shared infrastructure -- any system needing neighbor lookups can use the spatial grid without rebuilding it"
    - "The O(N^2) nested loop in combat_system is replaced with O(N*K) spatial grid lookups where K is avg entities per cell"
  artifacts:
    - path: "src/spatial.rs"
      provides: "SpatialGrid struct with insert, clear, and query_nearby methods"
      contains: "pub struct SpatialGrid"
    - path: "src/app.rs"
      provides: "SpatialGrid field in App struct, rebuild per tick, passed to combat_system"
      contains: "spatial_grid"
    - path: "src/systems/combat.rs"
      provides: "Updated combat_system using SpatialGrid instead of O(N^2) nested loop"
      contains: "SpatialGrid"
  key_links:
    - from: "src/app.rs"
      to: "src/spatial.rs::SpatialGrid"
      via: "App owns SpatialGrid, rebuilds per tick, passes to combat_system"
      pattern: "spatial_grid\\.clear\\(\\)|spatial_grid\\.insert"
    - from: "src/systems/combat.rs"
      to: "src/spatial.rs::SpatialGrid"
      via: "combat_system receives &SpatialGrid and calls query_nearby"
      pattern: "query_nearby"
---

<objective>
Implement a spatial hash grid for O(1) neighbor lookups, replacing the O(N^2) nested loop in the combat system.

Purpose: The combat system (combat.rs:42-56) uses a nested loop over all combatants to find adjacent enemies. At 500+ ants, this is O(N^2) = 250,000 comparisons every COMBAT_INTERVAL ticks, causing frame drops. A spatial hash grid reduces this to O(N*K) where K averages ~3 entities per cell, making combat scale linearly with ant count.

Output: A `SpatialGrid` module that partitions the map into cells, is rebuilt once per tick, and provides O(K) neighbor queries. The combat system uses it instead of the nested loop. The simulation maintains 30 FPS at 500+ ants.
</objective>

<execution_context>
@C:\Users\winte\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\winte\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-unfreeze-and-activate/01-01-SUMMARY.md
@.planning/phases/01-unfreeze-and-activate/01-02-SUMMARY.md
@src/app.rs
@src/systems/combat.rs
@src/systems/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SpatialGrid module</name>
  <files>src/spatial.rs, src/main.rs</files>
  <action>
  Create a new file `src/spatial.rs` with the SpatialGrid implementation.

  **In `src/spatial.rs`:**

  ```rust
  use hecs::Entity;

  /// Spatial hash grid for O(1) neighbor lookups.
  /// Divides the map into cells of `cell_size` tiles each.
  /// Rebuilt from scratch each tick (O(N) rebuild, O(K) query).
  pub struct SpatialGrid {
      cells: Vec<Vec<(Entity, i32, i32, u8)>>,  // entity, x, y, colony_id
      width: usize,   // grid width in cells
      height: usize,  // grid height in cells
      cell_size: i32,
  }

  impl SpatialGrid {
      /// Create a new spatial grid for a world of the given pixel dimensions.
      /// cell_size determines the granularity (8 is good for combat adjacency checks).
      pub fn new(world_width: usize, world_height: usize, cell_size: i32) -> Self {
          let width = (world_width as i32 / cell_size + 1) as usize;
          let height = (world_height as i32 / cell_size + 1) as usize;
          Self {
              cells: vec![Vec::new(); width * height],
              width,
              height,
              cell_size,
          }
      }

      /// Clear all entities from the grid. Called at the start of each tick.
      pub fn clear(&mut self) {
          for cell in &mut self.cells {
              cell.clear();
          }
      }

      /// Insert an entity at position (x, y) with its colony_id.
      pub fn insert(&mut self, entity: Entity, x: i32, y: i32, colony_id: u8) {
          let cx = (x / self.cell_size) as usize;
          let cy = (y / self.cell_size) as usize;
          if cx < self.width && cy < self.height {
              self.cells[cy * self.width + cx].push((entity, x, y, colony_id));
          }
      }

      /// Query all entities in the cell containing (x, y) and its 8 neighbors.
      /// Returns a Vec of (entity, x, y, colony_id) tuples.
      pub fn query_nearby(&self, x: i32, y: i32) -> Vec<(Entity, i32, i32, u8)> {
          let cx = (x / self.cell_size) as isize;
          let cy = (y / self.cell_size) as isize;
          let w = self.width as isize;
          let h = self.height as isize;

          let mut results = Vec::new();
          for dy in -1..=1isize {
              for dx in -1..=1isize {
                  let nx = cx + dx;
                  let ny = cy + dy;
                  if nx >= 0 && nx < w && ny >= 0 && ny < h {
                      let idx = ny as usize * self.width + nx as usize;
                      results.extend_from_slice(&self.cells[idx]);
                  }
              }
          }
          results
      }
  }
  ```

  Design notes:
  - Cell size 8: For a 200x100 map, this creates a 25x13 = 325 cell grid. With 500 ants, that averages ~1.5 entities per cell. Checking 9 cells per query = ~14 entity comparisons vs. O(N)=500.
  - `query_nearby` returns owned Vec, not iterator. This is simpler and avoids lifetime issues with the borrow checker in the combat system's mutation pattern. The Vec is small (typically <20 entries).
  - Negative coordinate handling: `x / cell_size` for negative x is UB-adjacent in integer division. Since all positions in AntTrails are non-negative (0..200, 0..100), this is safe. If negative coords are ever introduced, add `.max(0)` guards.

  **In `src/main.rs`:**

  Add `mod spatial;` to the module declarations. Place it alongside the other `mod` declarations (check where `mod systems;`, `mod components;`, etc. are declared and add `mod spatial;` in the same area).
  </action>
  <verify>
  1. `cargo build` succeeds -- the new module compiles.
  2. `src/spatial.rs` exists with `SpatialGrid` struct, `new`, `clear`, `insert`, `query_nearby` methods.
  3. `src/main.rs` contains `mod spatial;`.
  </verify>
  <done>
  SpatialGrid module exists at `src/spatial.rs` with the full API: `new`, `clear`, `insert`, `query_nearby`. The module is declared in `main.rs`. `cargo build` succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SpatialGrid into App and replace O(N^2) combat loop</name>
  <files>src/app.rs, src/systems/combat.rs</files>
  <action>
  **In `src/app.rs`:**

  1. Add import at the top: `use crate::spatial::SpatialGrid;`

  2. Add `spatial_grid: SpatialGrid` field to the `App` struct (after the `water` field is fine).

  3. In `App::new()`, initialize the spatial grid after the terrain is created:
     ```rust
     let spatial_grid = SpatialGrid::new(terrain.width, terrain.height, 8);
     ```
     Add `spatial_grid` to the `Ok(Self { ... })` struct initialization.

  4. In `App::update()`, at the START of each tick (after `self.tick += 1;`, before Phase 1 AI), rebuild the spatial grid:
     ```rust
     // Rebuild spatial grid for this tick
     self.spatial_grid.clear();
     for (_entity, (pos, _ant, member)) in
         self.world.query::<(&crate::components::Position, &crate::components::Ant, &crate::components::ColonyMember)>().iter()
     {
         self.spatial_grid.insert(_entity, pos.x, pos.y, member.colony_id);
     }
     ```
     Note: Use fully qualified paths or add the necessary imports. The query uses `(&Position, &Ant, &ColonyMember)` -- the `Ant` component is included to ensure we only index actual ants, not food sources or other positioned entities.

     Actually, check what imports `app.rs` already has. It likely imports from `crate::components` already for other uses. If `Position`, `Ant`, and `ColonyMember` are already imported, use the short names.

     If they are NOT imported (app.rs might only use them indirectly through systems), add:
     ```rust
     use crate::components::{Ant, ColonyMember, Position};
     ```

  5. Update the `combat_system` call (line 179) from:
     ```rust
     systems::combat::combat_system(&mut self.world, &mut self.pheromones, self.tick);
     ```
     to:
     ```rust
     systems::combat::combat_system(&mut self.world, &mut self.pheromones, self.tick, &self.spatial_grid);
     ```

  **In `src/systems/combat.rs`:**

  6. Add import: `use crate::spatial::SpatialGrid;`

  7. Change `combat_system` signature from:
     ```rust
     pub fn combat_system(world: &mut World, pheromones: &mut PheromoneGrid, tick: u64)
     ```
     to:
     ```rust
     pub fn combat_system(world: &mut World, pheromones: &mut PheromoneGrid, tick: u64, spatial_grid: &SpatialGrid)
     ```

  8. Replace the O(N^2) nested loop (lines 42-70) with spatial grid lookups. The new combat resolution logic:

     ```rust
     // Find adjacent enemies using spatial grid and resolve combat
     let mut damage_to_apply: Vec<(hecs::Entity, u8, u8)> = Vec::new();
     let mut danger_deposits: Vec<(i32, i32, u8)> = Vec::new();
     let mut processed_pairs: Vec<(hecs::Entity, hecs::Entity)> = Vec::new();

     for &(entity_a, x_a, y_a, colony_a, role_a, strength_a) in &combatants {
         for (entity_b, x_b, y_b, colony_b) in spatial_grid.query_nearby(x_a, y_a) {
             // Skip same colony
             if colony_a == colony_b {
                 continue;
             }

             // Skip if we already processed this pair (avoid double-counting)
             let pair = if entity_a < entity_b {
                 (entity_a, entity_b)
             } else {
                 (entity_b, entity_a)
             };
             if processed_pairs.contains(&pair) {
                 continue;
             }

             // Check if adjacent (including diagonals)
             let dist = (x_a - x_b).abs().max((y_a - y_b).abs());
             if dist > 1 {
                 continue;
             }

             // Find entity_b's combat stats from combatants list
             if let Some(&(_, _, _, _, role_b, strength_b)) = combatants.iter().find(|(e, _, _, _, _, _)| *e == entity_b) {
                 // Combat! Each deals damage to the other
                 let damage_a = calculate_damage(strength_a, role_a);
                 let damage_b = calculate_damage(strength_b, role_b);

                 damage_to_apply.push((entity_b, damage_a, colony_a));
                 damage_to_apply.push((entity_a, damage_b, colony_b));

                 // Deposit danger pheromones
                 danger_deposits.push((x_a, y_a, colony_a));
                 danger_deposits.push((x_b, y_b, colony_b));

                 processed_pairs.push(pair);
             }
         }
     }
     ```

     IMPORTANT: The spatial grid query returns entities from ALL colonies. We must:
     - Skip same-colony pairs (colony_a == colony_b)
     - Track processed pairs to avoid double-counting (A fights B and B fights A)
     - Still look up entity_b's role and strength from the combatants vec

     The `processed_pairs` vec prevents the duplication issue that would arise because both entity_a and entity_b will find each other in their respective `query_nearby` calls. Using `entity_a < entity_b` for canonical pair ordering keeps this simple.

     Alternative approach if `processed_pairs.contains()` is too slow at high entity counts: use a `HashSet<(Entity, Entity)>`. But for the expected entity densities (500-1000 ants, typically <5 combatant pairs per tick), a Vec with linear scan is fine.

  Keep the damage application and danger deposit code UNCHANGED (lines 72-80 in the original) -- only the neighbor-finding loop changes.
  </action>
  <verify>
  1. `cargo build` succeeds with zero errors.
  2. `cargo run` -- verify that combat still works:
     - When ants from different colonies are adjacent, they fight (soldiers take damage, danger pheromones appear)
     - Ants die from combat damage as before
     - No panics or unexpected behavior
  3. Verify the O(N^2) loop is gone:
     - `grep -n "for j in (i + 1)" src/systems/combat.rs` returns zero results
     - `grep -n "query_nearby" src/systems/combat.rs` returns at least one result
  4. Verify spatial grid integration:
     - `grep -n "spatial_grid" src/app.rs` returns multiple results (field, init, clear, insert, pass to combat)
  </verify>
  <done>
  SpatialGrid is created in App, rebuilt every tick, and passed to combat_system. The O(N^2) nested loop in combat_system is replaced with spatial grid lookups. Combat still works correctly -- adjacent enemies fight, damage is applied, danger pheromones are deposited. `cargo build` succeeds. The simulation can scale to 500+ ants without frame drops from neighbor lookups.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` completes with zero errors
2. `src/spatial.rs` exists with `SpatialGrid` struct
3. `src/app.rs` creates, clears, rebuilds, and passes `SpatialGrid` every tick
4. `src/systems/combat.rs` uses `query_nearby` instead of nested loop
5. `grep -n "for j in (i + 1)" src/systems/combat.rs` returns zero (O(N^2) gone)
6. `cargo run` shows combat still functioning (ants fight when adjacent, take damage, die)
7. No frame drops observed at normal ant counts
</verification>

<success_criteria>
- SpatialGrid module exists with new/clear/insert/query_nearby API
- SpatialGrid is rebuilt once per tick in App::update()
- combat_system uses SpatialGrid for neighbor lookups instead of O(N^2) loop
- Combat behavior is unchanged -- same adjacency checks, same damage, same pheromone deposits
- No duplicate combat resolution (pair deduplication works)
- The code compiles cleanly with `cargo build`
- Performance is improved for high ant counts (O(N*K) vs O(N^2))
</success_criteria>

<output>
After completion, create `.planning/phases/01-unfreeze-and-activate/01-03-SUMMARY.md`
</output>
